#!/bin/bash

# Nom du bookmark pour lftp
DEBUG_MODE=1  # Mettre √† 1 pour activer le mode d√©bogage (ne pas supprimer les fichiers temporaires)
BOOKMARK="seedbox"
REMOTE_PATH="/data/complete/"
LOCAL_PATH=$(echo "$PWD" | sed "s/'/\\'/g" | sed 's/ /\\ /g')
RESULT_FILE="/tmp/search_sdbx_result"
SEARCH_TERMS=() # Tableau pour stocker les termes de recherche cumul√©s

# V√©rifier si l'option -m ou --missing est pass√©e
CHECK_MISSING=0
OR_SEARCH=0
KEEP_DIRECTORY=0

for arg in "$@"; do
    case "$arg" in
        -m|--missing)
            CHECK_MISSING=1
            ;;
         -o|--or)
	    OR_SEARCH=1
	    shift
	    ;;
	 -d|--directory)
	    KEEP_DIRECTORY=1
	    shift
	    ;;
    esac
done

if [[ ! -d "$PWD" ]]; then
    echo "Erreur : Le r√©pertoire local $PWD n'existe pas."
    exit 1
fi

### üìå Fonction : G√©n√©rer la liste des fichiers depuis le serveur
function generate_server_file_list() {
    echo "üîÑ G√©n√©ration de la liste des fichiers du serveur..."
    lftp -e "
    set ftp:list-options -a;
    open $BOOKMARK;
    ls -R > "$RESULT_FILE"
    bye;" > /dev/null 2>&1

}

### üìå Fonction : Filtrer et nettoyer la liste des fichiers
function process_file_list() {
    echo "üîÑ Traitement des fichiers..."

    # V√©rifier que le fichier existe avant de continuer
    if [[ ! -s "$RESULT_FILE" ]]; then
        echo "‚ùå Erreur : Impossible de r√©cup√©rer la liste des fichiers."
        return 1
    fi

    # V√©rification et extraction des types MIME si -m est activ√©
    if [[ "$CHECK_MISSING" -eq 1 ]]; then
        local args=("$@")

        # Tableau associatif des cat√©gories MIME
        declare -A MIME_MAP
        MIME_MAP["videos"]="^video/"
        MIME_MAP["livres"]="^(application/epub|application/pdf|application/vnd.amazon|application/msword|application/vnd.openxmlformats-officedocument.wordprocessingml)"

        # Exclure "-m" des arguments trait√©s
        MIME_CATEGORIES=()
        PARSE_MODE=0

        for arg in "$@"; do
            if [[ "$arg" == "-m" ]]; then
                PARSE_MODE=1
                continue
            fi
            if [[ "$PARSE_MODE" -eq 1 ]]; then
                MIME_CATEGORIES+=("$arg")
            fi
        done

        echo "üìå Cat√©gories demand√©es : ${MIME_CATEGORIES[*]}"

        # Construction de la liste des extensions
        EXTENSIONS=""
        for category in "${MIME_CATEGORIES[@]}"; do
            if [[ -n "${MIME_MAP[$category]}" ]]; then
                echo "üîç Recherche des extensions pour : $category"
                
                MIME_EXT=$(grep -E "${MIME_MAP[$category]}" /etc/mime.types | awk '{for (i=2; i<=NF; i++) print $i}' | tr '\n' '|' | tr -s ' ' | sed 's/|$//')

                if [[ -z "$MIME_EXT" ]]; then
                    echo "‚ö†Ô∏è Aucune extension trouv√©e pour $category !"
                else
                    echo "‚úî Extensions trouv√©es : $MIME_EXT"
                    EXTENSIONS+="$MIME_EXT|"
                fi
            else
                echo "‚ö†Ô∏è Cat√©gorie inconnue : $category"
            fi
        done

        # Supprimer le dernier '|' s'il existe
        EXTENSIONS="${EXTENSIONS%|}"

        # V√©rifier que la liste des extensions est valide
        if [[ -z "$EXTENSIONS" ]]; then
            echo "‚ùå Erreur : Aucune extension r√©cup√©r√©e ! Types disponibles : \"videos\", \"livres\""
            exit 1
        fi

        echo "üì∫ Extensions finales : $EXTENSIONS"

        # Expression r√©guli√®re pour exclure les fichiers de formation
        NUMERATION="^([0-9]+([._-][0-9]+)?[._-]?[ ]?)"

        # Ex√©cution d awk pour filtrer uniquement les fichiers vid√©o et livres sans num√©rotation indicative de formation
        awk -v ext_list="$EXTENSIONS" -v numeration="$NUMERATION" '{
            if ($1 ~ /^-/) {  
                name = "";
                for (i=9; i<=NF; i++) {
                    name = name $i " ";
                }

                # Suppression de l espace final si pr√©sent
                if (substr(name, length(name), 1) == " ") {
                    name = substr(name, 1, length(name) - 1);
                }

                # V√©rifie si le fichier appartient aux types MIME demand√©s et ne suit pas une num√©rotation indicative de formation
                if (name ~ ("\\.(" ext_list ")$") && name !~ numeration) {
                    print name;
                }
            }
        }' "${RESULT_FILE}" > "${RESULT_FILE}_filtered_clean"

    else
        # Filtrage des r√©sultats normaux (recherche texte)
	
	if [[ $KEEP_DIRECTORY -eq 0 ]]; then
	    sed '/^d/d' "${RESULT_FILE}" > "${RESULT_FILE}_t";
	else
	    cat "${RESULT_FILE}" > "${RESULT_FILE}_";
	fi

	awk '{
    	if ($1 ~ /^[dl-]/) {
            print substr($0, index($0, $9));
    	  }	
	}' "${RESULT_FILE}_t" > "${RESULT_FILE}_"


	if [[ "$OR_SEARCH" -eq 0 ]]; then
	    filtered_result=$(cat "${RESULT_FILE}_")
	fi
	
	if [[ -s "${RESULT_FILE}_" ]]; then
            for term in "${SEARCH_TERMS[@]}"; do
                term=$(echo "$term" | tr -d '\n' | tr -d '\r')
                
		if [[ -n "$term" ]]; then
                    if [[ "$OR_SEARCH" -eq 1 ]]; then
			filtered_result+=$'\n'$(cat "${RESULT_FILE}_" | grep -iF "$term" || true)
		    else
			filtered_result=$(echo "$filtered_result" | grep -iF "$term" || true)
		    fi
                fi
            done
        else
            echo "Erreur : Fichier de r√©sultats vide."
            return
        fi

        # V√©rifier si la recherche a trouv√© quelque chose
        if [[ -z "$filtered_result" ]]; then
            echo "Aucun fichier trouv√© correspondant aux crit√®res : ${SEARCH_TERMS[*]}."
            exit 0
        else
            echo "$filtered_result" > "${RESULT_FILE}_filtered"

	    if [[ "$OR_SEARCH" -eq 1 ]]; then
	        sed -i '1d' "${RESULT_FILE}_filtered"
	    fi
        fi

        sed 's/ $//' > "${RESULT_FILE}_filtered_clean" "${RESULT_FILE}_filtered" #TODO t√©l√©charger les fichiers missing 
    fi
}


### üìå Fonction : G√©n√©rer les chemins absolus
function generate_absolute_paths() {
    echo "üîÑ G√©n√©ration des chemins absolus..."
    
    awk '
    /:$/ { current_dir = substr($0, 1, length($0) - 1); next }
    !/:$/ && $1 !~ /^d/ && $NF != "." && $NF != ".." {
        print current_dir "/" substr($0, index($0, $9))
    }' "$RESULT_FILE" > "${RESULT_FILE}_abs_paths"

    awk '{sub(/\/[^\/]+ [0-9]+ +[0-9]+ +[A-Z][a-z]{2} [0-9]{1,2} [0-9]{2}:[0-9]{2} /, "/")}1' "${RESULT_FILE}_abs_paths" > "${RESULT_FILE}_abs_paths.tmp"
    mv "${RESULT_FILE}_abs_paths.tmp" "${RESULT_FILE}_abs_paths"
}

### üìå Fonction : Rechercher et t√©l√©charger les fichiers
function search_and_download() {
    echo "üîé Recherche des fichiers contenant : ${SEARCH_TERMS[*]}"

    # G√©n√©rer et traiter la liste des fichiers
    generate_server_file_list
    process_file_list
    generate_absolute_paths

    echo -e "üìÑ R√©sultats trouv√©s :\e[35m"

   # sed -i '1d' "${RESULT_FILE}_filtered_clean"
    #sed -i '1d' "${RESULT_FILE}_filtered"
    # Ajouter des num√©ros devant chaque fichier pour faciliter le choix
    nl -w2 -s' ' "${RESULT_FILE}_filtered_clean" > "${RESULT_FILE}_filtered_numbered"
    
    cat "${RESULT_FILE}_filtered_numbered"
    echo -e "\e[0m"

    while true; do
        read -p "Voulez-vous t√©l√©charger ces fichiers ? (o : tout, n : annuler, num√©ros s√©par√©s par espace : s√©lection, autre : affiner) " choice
        
        case $choice in
            [oOyY]* )  # ‚úÖ T√©l√©charger tout
		readarray -t selected_files < "${RESULT_FILE}_filtered_clean"
		;;
            [nN]* )  # ‚ùå Annuler
                echo "‚ùå Recherche abandonn√©e."
                break
                ;;
            *[0-9]* )  # üî¢ T√©l√©chargement s√©lectif via num√©ros
                selected_files=()
                for num in $choice; do
                    file=$(sed -n "${num}p" "${RESULT_FILE}_filtered_clean")
                    echo "ligne $num"
                    echo "$file"
                    if [[ -n "$file" ]]; then
                        selected_files+=("$file")
                    else
                        echo "‚ö†Ô∏è Num√©ro $num invalide, ignor√©."
                    fi
                done
                ;;
            * )  # üîç Recherche continue avec nouveaux crit√®res
                SEARCH_TERMS+=("$choice")
                search_and_download
                return
                ;;
        esac

        if [[ ${#selected_files[@]} -eq 0 ]]; then
            echo "‚ö†Ô∏è Aucun fichier s√©lectionn√©, veuillez recommencer."
            continue
        fi

        echo "üì• T√©l√©chargement des fichiers s√©lectionn√©s..."

	CLEANUP_RULES='s/\t/ /g; s/  */ /g; s/^ *//; s/ *$//'
	
	sed -e "$CLEANUP_RULES" "${RESULT_FILE}_abs_paths" > "${RESULT_FILE}_abs_paths_clean"

        for line in "${selected_files[@]}"; do
	    echo "$line";
	    # V√©rifier si c'est un dossier (pas d'extension d√©tect√©e) TODO g√©rer le t√©l√©chargement des dossiers
            if [[ ! "$line" =~ \.[a-zA-Z0-9]{2,4}$ ]]; then
                read -p "‚ö†Ô∏è \"$line\" est un dossier. Voulez-vous le t√©l√©charger ? (o/n) " confirm_dir
                if [[ "$confirm_dir" =~ ^[nN]$ ]]; then
                    echo "‚è≠Ô∏è Dossier \"$line\" ignor√©."
                    continue  # Passer au fichier suivant
                fi
            fi

            echo "üì• T√©l√©chargement de : \"$line\""
            
            normalized_line=$(echo "$line" | sed 's/^ *//; s/ *$//; s/  */ /g')
            matching_line=$(grep -F "$normalized_line" "${RESULT_FILE}_abs_paths_clean")

            if [[ -n "$matching_line" ]]; then
            echo $matching_line #TODO g√©rer les fichiers qui ont le m√™me nom ? pour "solution" ici le retour est ./data/complete/JavaScript - The Complete Guide 2020 (Beginner + Advanced) - [Udemy][Anglais]/02. Basics Variables, Data Types, Operators & Functions/14. Time to Practice Variables, Constants, Operators & Core Data Types/solution.mp4 ./data/complete/JavaScript - The Complete Guide 2020 (Beginner + Advanced) - [Udemy][Anglais]/02. Basics Variables, Data Types, Operators & Functions/26. Time to Practice Functions/solution.mp4 ./data/complete/JavaScript - The Complete Guide 2020 (Beginner + Advanced) - [Udemy][Anglais]/04. Working with Control Structures (if Statements, Loops, Error Handling)/35. Time to Practice Control Structures/solution.mp4 ./data/complete/JavaScript - The Complete Guide 2020 (Beginner + Advanced) - [Udemy][Anglais]/06. More on Functions/19. Time to Practice Functions/solution.mp4 ./data/complete/JavaScript - The Complete Guide 2020 (Beginner + Advanced) - [Udemy][Anglais]/07. Working with the DOM (Browser HTML Code) in JavaScript/12. Time to Practice DOM Querying/solution.mp4 ./data/complete/JavaScript - The Complete Guide 2020 (Beginner + Advanced) - [Udemy][Anglais]/08. More on Arrays & Iterables/28. Time to Practice Arrays & Iterables/solution.mp4 ./data/complete/JavaScript - The Complete Guide 2020 (Beginner + Advanced) - [Udemy][Anglais]/10. Classes & Object-oriented Programming (OOP)/22. Time to Practice Classes & OOP/solution.mp4 ./data/complete/JavaScript - The Complete Guide 2020 (Beginner + Advanced) - [Udemy][Anglais]/35. Bonus Web Components/21. Time to Practice - The Basics/solution.mp4
                
	        line_number=$(grep -n -F "$matching_line" "${RESULT_FILE}_abs_paths_clean" | cut -d: -f1)
                absolute_path=$(sed -n "${line_number}p" "${RESULT_FILE}_abs_paths")
		# absolute_path=$(grep -F "$matching_line" "${RESULT_FILE}_abs_paths" | sed 's/ /\\ /g; s/(/\\(/g; s/)/\\)/g')
		
		awk '{
		    if ($1 ~ /^[dl-]/) {
        	        print substr($0, index($0, $9));
   		    }
		}' "${RESULT_FILE}_t" > "${RESULT_FILE}_"

                if [[ -z "$absolute_path" ]]; then
                    echo "‚ùå Erreur : Chemin absolu introuvable pour \"$line\"."
                    continue
                fi

                echo "üìÇ Commande : pget -n 4 -c \"$absolute_path\" -o $LOCAL_PATH/"

                lftp -c "
        	set ftp:list-options -a;
                set ftp:use-stat -a;
                set net:idle 10;
                set net:timeout 30;
                set cmd:fail-exit yes;
                set ftp:passive-mode on;
                open $BOOKMARK;
                pget -n 4 -c \"$absolute_path\" -o $LOCAL_PATH/;
                bye;
                " 
            echo "üì• T√©l√©chargement des fichiers s√©lectionn√©s..."

	    else
                echo "‚ùå Aucun fichier trouv√© correspondant √† '$line'"
                exit 1
            fi
        done

        echo "‚úÖ T√©l√©chargement termin√©."
        break
    done
}

### üìå Fonction : Comparer les fichiers avec ceux en local
function check_missing_files() {
    echo "üìÇ Comparaison des fichiers entre le serveur et le local..."

    # G√©n√©rer et traiter la liste des fichiers
    generate_server_file_list
    process_file_list "$@"

    find "$LOCAL_PATH" -type f -printf "%f\n" > /tmp/local_files.txt #TODO sp√©cifier le chemin en param√®tre
    missing_files=$(comm -23 <(sort "${RESULT_FILE}_filtered_clean") <(sort /tmp/local_files.txt))

    if [[ -z "$missing_files" ]]; then
        echo "‚úÖ Tous les fichiers sont d√©j√† pr√©sents en local."
        exit 0
    fi

    echo "üöÄ Fichiers absents en local :"
    echo "$missing_files" | tee /tmp/missing_files.txt
}

### üìå Ex√©cution principale ###
if [[ -z $1 ]]; then
    echo "Usage : wgets2 \"texte_de_recherche\""
    exit 1
fi

if [[ "$CHECK_MISSING" -eq 1 ]]; then
    check_missing_files "$@"
    exit 0
else
    SEARCH_TERMS=("$@")
    search_and_download
fi
 echo "or-search : $OR_SEARCH";   
if [[ "$DEBUG_MODE" -eq 0 ]]; then
    echo "üßπ Nettoyage des fichiers temporaires..."
    rm -f "$RESULT_FILE" \
          "${RESULT_FILE}_filtered" \
          "${RESULT_FILE}_filtered_clean" \
          "${RESULT_FILE}_abs_paths" \
          "${RESULT_FILE}_abs_paths_clean"
fi
